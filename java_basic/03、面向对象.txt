引入：将方法封装起来  
你有没有这个功能？有我就用，变得太懒了。
面向对象思想
从执行者变成指挥者

面向对象是基于面向过程的编程思想

面向对象开发设计及特征
开发：就是不断的创建对象，使用对象，指挥对象做事情
设计：管理和维护对象之间的关系
特征：封装、继承、多态

封装：指隐藏对象的属性和实现细节，仅对外提供公共的访问方式。
好处：隐藏细节，提供公共的访问方式
         提高代码的复用性
         提高安全性
封装原则：
         将不需要的对外提供的内容都隐藏起来
         把属性隐藏，提供公共方法对其访问
private 权限修饰符，可以修饰成员变量和成员方法，被修饰的成员变量和方法只能在本类中访问
	提供对应的getXxxx()和setXxxx()
this:当前类的对象引用。代表当前类的一个对象。
	解决局部变量隐藏成员变量。
构造方法用于初始化数据。
成员变量是用于描述类的信息的。
变量的范围越小越好，能够及时被回收

能不能把各类中相同的内容定义到一个独立的类中。
然后让这多各类和这个独立的类产生一个关系。这多个类就可以具备这个独立的类的内容
继承：extends关键字
	class 子类名 extends 父类名
好处：提高了代码的复用性
          提高了代码的维护性
          让类与类之间产生关系，是多态的前提
弊端：类的耦合性增加
开发的原则：低耦合，高内聚
          耦合：类与类的关系
          内聚：自己完成某件事情的能力

java中只支持单继承，不支持多继承 extends  father mather{ }这个不能够使用
	       支持多层继承
注意：a、子类只能继承父类所有的非私有成员（成员方法和成员变量）
          b、子类不能继承父类的构造方法，但是可以通过super进行访问父类的构造方法
          c、不要为了部分功能去继承
继承体现的is-a的关系：
继承中成员变量的关系：
	a、子类的成员变量和父类的成员变量名称一样
	b、名称一样，就近原则
	访问父类的成员范围的成员变量
	super.num打印父类的成员变量
this 和super的区别
	this代表本类对象的引用
・	super代表父类存储空间的标志，可以理解为父类引用,可以操作父类的成员
	this();调用本类的构造方法
	super();调用父类的构造方法
	this.成员方法
	super.成员方法
继承中的构造方法的关系
1、子类中所有的构造方法都会默认的访问父类的无参构造方法
2、子类的每一个构造方法默认的构造方法是super();

静态代码块>构造代码块>构造方法
父类的静态代码块
子类的静态代码块
父类的构造代码块
父类的构造方法
子类的构造代码块
子类的构造方法

多态：
某一事物在不同的时刻表现得不同的状态
前提：
	要有继承	
	要有方法重写
	要有父类引用指向子类对象
	动物 d=new 猫();
	动物 d=new 狗(); d.show();

多态中成员的访问特点：
	A:成员变量
	     拿的是父类的成员变量 ，编译看左边，运行看左边
	B:构造方法
	     创建子类对象的时候，访问父类的构造方法，对父类进行初始化。
	C:成员方法
	           编译看左边，运行看右边
	D:静态方法
		编译看左边，运行看左边
		静态和类相关，算不上重写，所以访问看左边
好处：
	A:代码的维护性
	B:提高了代码的拓展性
在工具类中，把构造方法私有，外界不能进行初始化。
工具类中使用静态方法，只能使用类进行调用
class AnimalTool{
	private AnimalTool(){}
	public static useAnimal(Animal a)
{
	a.eat();
	a.sleep();
}
}
AnimalTool.useAnimal(d);
弊端：
	不能使用子类特有的功能
解决方案：
	A:创建一个子类对象，占内存空间
	B:将父类的引用强制转化为子类的对象。（向下转型）
	new fu=new ZI();
	new zi=(ZI)fu;
	ZI.show();
	ZI.method(); //只有一个对象

Exception:class cast exception猫不能强转成狗 向下转型中出现