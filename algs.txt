1、欧里几得算法：计算两个非负整数p 和q的最大公约数：若q 为0，则最大公约数为p
，否则，(p%q=r)将p除以q得到余数r，p 和q的最大公约数变为q 和r的最大公约数。
	互质，没有公约数
2、二分法查找
  针对有序数据 first last mid=(first+last )/2  
3、数组处理：
	找出最大值  遍历法
	计算出平均值，先求和 
	复制数组，b[i]=a[i]
	颠倒数组，借助中间变量
4、典型的静态方法 
	计算一个整数的绝对值 x<0?-x:x;     
	素数的判断：能被自身和1以外的数整除的数（i=0 ;i*i <n;i++） n%i==0为素数
	牛顿迭代法？：用现成的
	调和级数？1+1/2+1/3+...+1/N
模块化编程：将精力集中在算法上

5、类型转换
	parseTnt(String s) 将s转换为整数  //对于特别大的需要手动实现
	toString(int i)
	parseDouble(String s) 
	toString(double x)
6、将一个正整数N用二进制表示并转化为一个String
	Integer.toBinaryString(N)专门用于完成该任务
	对2取余数，然后拼接。String s="";for (int n=N;n>0;n/=2)s=(n%2)+s;
7、斐波那契数列优化  直接使用数组
8、？删除重复元素、等值键 
9、？矩阵处理            相乘线代又忘了？C++的化用eigen库，Java的化也找矩阵相关的库
		 转置	
10、统计学编程  中位数、众数等
面向对象思想：定义和使用数据类型，将数据类型的值分装在对象中的方式称为面向对象编程

11、判断字符串是否回文，看一半，如果str.chartAt(i)!=str.charAt(length-1-i);
如果该值在初始化后不想被改变，则使用final
12、记录能够使用reverse 的数据类型或collections
13、栈的应用：计算表达式的值。。。好像不用直接输入就可以得到值。
	        判断括号匹配的问题。对左括号压栈遇到右括号就出栈。

14、？连通性算法 先存疑问。初步想法，如果一个元素与另一个元素在同一个集合中就来连通。那么路径又该怎么表示？


15、排序问题
每个元素都有一个主键
比较compare和交换主键位置
选择排序：当前元素往后，选择剩余元素选比当前值小的元素放在这里 每次通过比较找出最小元素
插入排序：将当前元素插入到前面已经排序好的序列的适当位置
希尔排序：	
归并排序：     java版本暂时没看进去
快排：

16、查找
